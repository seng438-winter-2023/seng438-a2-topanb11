**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#2 – Requirements-Based Test Generation**

| Group \#:      |  22   |
| -------------- | --- |
| Student Names: | Topan Budiman   |
|                | Mark Ngu    |
|                | Jacob Schon     |
|                | Muhammed Shah     |

# 1 Introduction

The goal of this assignment is to utilize black-box testing to perform unit tests on two different classes DataUtilities and the Range class. We will be writing unit tests based on the requirements of 5 methods in each class. To carry out these tests, we will be using proper black-box testing techniques such as boundary value testing (BVT) and equivalence class testing (ECT). By following this procedure, it will ensure that our tests are thorough and cover all possible cases.

# 2 Detailed description of unit test strategy

For our unit testing strategy, we started off by planning how we would perform our tests before writing any code. This involved reading the javadoc documentation for the Range and DataUtilities class to ensure we understand the requirements of each of the following classes. After we understood the requirements of the assigned methods, we applied black-box testing techniques to ensure we tested every method thoroughly and covered all possible cases. We utilized a combination of boundary value testing (BVT) along with equivalence class testing (ECT) to do so. 

For the Range class, since we were dealing with values that were in between two arbitrary values, we mainly used BVT to perform our tests. The reason we utilized BVT for our tests is because there are clear distinguishable boundaries in the Range class. This made it relatively simple to test the various bounds including: below lower bound, at the lower bound, within the bounds, at the upper bound and above the upper bound. Since each bound was able to be tested with ease, this allowed us to cover all possible cases and possible edge cases. Mocking was not necessary when testing the methods since the Range class did not depend on any external classes. Due to that, we were able to successfully perform unit testing on the Range class.

For the DataUtilities class, we had to first determine which methods had interfaces as arguments. The methods with interfaces as arguments require mocking to simulate objects of the Values2D and KeyedValues interfaces.

# 3 Test cases developed

| Test Name  | What is being tested  | Expected Value  | Actual Value  | Pass/Fail  |
|---|---|---|---|---|
| getLengthTestDifferentValues()  | Testing the getLength() method to see if it returns the correct difference between the upper and lower bound when they are different values | 10.0   | 10.0  | Pass  |
| getLengthTestEqualValues()  | Testing the getLength() method to see if it returns the correct difference between the upper and lower bound when they are equal values  | 0  | 0  | Pass  |
| getUpperBoundTestDifferentValues()  | Testing the getUpperBound() method to see if it returns the correct upper bound when the the upper and lower bound are different values  | 5.0  | -5.0  | Fail  |
| getUpperBoundTestEqualValues()  | Testing the getUpperBound() method to see if it returns the correct upper bound when the the upper and lower bound are equal values  | 5.0  | 5.0  | Pass  |
| getLowerBoundTestDifferentValues()  | Testing the getLowerBound() method to see if it returns the correct lower bound when the the upper and lower bound are different values  | -5.0  | -5.0  | Pass  |
| getLowerBoundTestEqualValues()  | Testing the getLowerBound() method to see if it returns the correct lower bound when the the upper and lower bound are equal values  | 5.0  | 5.0  | Pass  |
| containsTestBLB()  | Testing the contains(double value) method to see if returns the correct boolean when a value below the lower bound is entered  | false  | false  | Pass  |
| containsTestLB()  | Testing the contains(double value) method to see if returns the correct boolean when a value that is at the lower bound is entered  | true  | true  | Pass  |
| containsTestNOM()  | Testing the contains(double value) method to see if returns the correct boolean when a value that is within the given range  | true  | true  | Pass  |
| containsTestUB()  | Testing the contains(double value) method to see if returns the correct boolean when a value that is at the upper bound is entered  | true  | true  | Pass  |
| containsTestAUB()  | Testing the contains(double value) method to see if returns the correct boolean when a value above the upper bound is entered  | false  | false  | Pass  |
| intersectionTestBLB()  | Testing the intersects(double lower, double upper) method to see if it returns the correct boolean when the two values provided are below the lower bound | false  | true  | Fail  |
| intersectionTestLB() | Testing the intersects(double lower, double upper) method to see if it returns the correct boolean when one of the provided values is at the lower bound and the other is below | true | true | Pass |
| intersectionTestNOM() | Testing the intersects(double lower, double upper) method to see if it returns the correct boolean when the two values provided are within the given range | true | true | Pass |
| intersectionTestUB() | Testing the intersects(double lower, double upper) method to see if it returns the correct boolean when one of the provided values is at the upper bound and the other is above | true | false | Fail |
| intersectionTestAUB() | Testing the intersects(double lower, double upper) method to see if it returns the correct boolean when the two values provided are above the upper bound | false | false | Pass |
| calculateColumnTotalForTwoValues() | Testing if calculateColumnTotal calculates the correct double when adding values from two rows together | 10.0 | 10.0 | Pass
| calculateColumnTotalForTwoValuesOneNegative() | Testing if calculateColumnTotal calculates the correct double when adding values where one is negative from two rows together | 5.0 | 5.0 | Pass |
| calculateColumnTotalForTwoValuesBothNegative() | Testing if calculateColumnTotal calculates the correct double when adding values where both are negative from two rows together | -10.0 | -10.0 | Pass |
| calculateColumnTotalZeroValues() | Testing if calculateColumnTotal calculates the correct double when there are 0 rows | 0.0 | 0.0 | Pass |
| calculateColumnTotalTestInvalidData() | Testing if the correct exception is thrown when invalid parameters are passed | IllegalParameterExceptionThrown | nothing | Fail |
| calculateRowTotalForTwoValues | Testing if calculateRowTotal calculates the correct double when adding values from two columns together | 10.0 | 7.5 | Fail |
| calculateRowTotalForTwoValuesOneNegative() | Testing if calculateRowTotal calculates the correct double when adding values where one is negative from two columns together | 5.0 | 7.5 | Fail |
| calculateRowTotalForTwoValuesBothNegative() | Testing if calculateRowTotal calculates the correct double when adding values where both are negative from two columns together | -10.0 | -7.5 | Fail |
| calculateRowTotalZeroValues() | Testing if calculateRowTotal calculates the correct double when there are 0 columns | 0.0 | 0.0 | Pass |
| calculateRowTotalTestInvalidData() | Testing if the correct exception is thrown when invalid parameters are passed | IllegalParameterExceptionThrown | nothing | Fail |
| createNumberArrayTestTwoValueArray() | Testing if createNumberArray properly creates a Number array with the given double array | {0, 2} | {0, null} | Fail |
| createNumberArrayTestTwoValueArray() | Testing if createNumberArray properly creates an empty Number array | {{}} | {{}} | Pass
| createNumberArray2DTestTwoByTwoArray() | Testing if createNumberArray2D properly creates a 2D Number array with the given 2D double array | [0][1] = {0,2} | [0][1] = {0,null} | Fail
| createNumberArray2DTestTwoValueArray() | Testing if createNumberArray2D properly creates an empty 2D Number array | {{}} | {{}} | Pass |
| getCumulativePercentagesTestThreeKeyValuePairs() | Testing if getCumulativePercentages properly calculates the cumulative percentage of each key value pair | Key: 1 value: 0.3125 | Key: 1 Value: 0.45454545 | Fail |


#### Notes:
- The range that was used when testing the contains() and intersects() method was [-5, 5] to cover more values and cases
- When testing the methods for range, two Range objects were used for each test:
  - testRangeDifferent: The range used was [-5,5] as the two values were different and it was a valid range 
  - testRangeEqual: The range used was [5,5] as the two values were equal

# 4 How the team work/effort was divided and managed

In order to divy up this assignment we split our group up into two pairs, Jacob/Gabe and Topan/Muhammed. There were 10 methods that we needed to test using black box unit testing, 5 range class and 5 data utilities class methods. Topan and Muhammed did the 5 range tests and Jacob and Gabe did the 5 data utility tests. We used a pair programming methodology to program the required tests to ensure all requirements were met. Since the range tests proved to be more straightforward and did not require mocking for the interfaces Topan and Muhammed took on more of the writing portion of the assignment’s report. Topan took the role of manager for this assignment, ensuring that timelines and goals were met. He set up our repository and generated the table formats for our reports in the markdown file.


# 5 Difficulties encountered, challenges overcome, and lessons learned

A major difficulty that we encountered was using proper black box testing techniques such as boundary value testing and equivalence class testing. Although most tests could be written easily in a few lines, utilizing these testing techniques allowed a wider range of values to be covered. Overall, this prevented any edge cases we would have missed in our testing. In both pairs, we noticed that we spent a significant amount of our time planning the tests vs actually writing them out. At first, the mocking proved to be difficult for the interfaces because a clear understanding of the interfaces and the methods were required in order to mock an object. We learnt that the mocking context would set the return values that would be expected from calling methods of the interface. 

# 6 Comments/feedback on the lab itself
- The javadoc documentation for each class was very thorough and made unit testing very straight forward
